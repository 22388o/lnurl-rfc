LUD-18: Payer identity in `payRequest` protocol.
================================================

`author: akumaigorodski` `author: hampus_s` `author: fiatjaf`

---

## 1. Specifying payer identity before sending a payment

Payer MAY attach a `payerid` query parameter to LNURL-PAY callback with value set to JSON array:

```diff
- <callback><?|&>amount=<milliSatoshi>
+ <callback><?|&>amount=<milliSatoshi>&payerid=[<identity record>, ...]
```

JSON array may contain one or more records of the following forms:

1. `{ "tag": "name", "value": <free-form string> }`
2. `{ "tag": "pubkey", "value": hex(<randomly generated secp256k1 pubkey>) }`
3. `{ "tag": "auth", "value": hex(<linkingKey>), "sig": hex(sign(utf8ToBytes(<k1>), <linkingPrivKey>)) }` // following [LUD-04](04.md)
4. `{ "tag": "identifier", "value": <internet identifier> }`
5. `{ "tag": "email", "value": <email address> }`

## 2. `PayerIDs` record

If `SERVICE` wants to get one or more types of payer identities from `WALLET` then it must alter its JSON response to the first callback to include a `payerIDs` field, as follows:

```diff
 {
   callback: String,
   maxSendable: MilliSatoshi,
   minSendable: MilliSatoshi,
   metadata: String,
+  payerIDs: {
+    "name": { "mandatory": Boolean },
+    "pubkey": { "mandatory": Boolean },
+    "identifier": { "mandatory": Boolean },
+    "email": { "mandatory": Boolean },
+    "auth": {
+       "mandatory": Boolean,
+       "k1": String // hex encoded 32 bytes of challenge
+    ]
+  },
   tag: "payRequest",
 }
```

`WALLET` CAN send any of the payer id kinds if they are listed in the `payerIDs` record. But if any is marked as `"mandatory": true` `WALLET` must send it if it can, otherwise do not proceed to payment.

`WALLET` SHOULD NOT send payer identity types omitted in `payerIDs` record, none at all if record is not present.

## 3. Committing payer to the invoice

If `SERVICE` requests (section 2) and `WALLET` sends a `payerid` record in the callback (section 1), the payer IDs must be committed to the metadata before the invoice is created.

`SERVICE` MUST append it to the metadata as it was received (after url-decoding), as in the following example:

```diff
 [["text/plain", "description"], ["image/png;base64", "AAA=="]]
+[["text/plain", "description"], ["image/png;base64", "AAA=="]][<identity record>, ...]
```

After doing that, `SERVICE` can proceed to hash the metadata and include that hash in the generated BOLT11 invoice as the `descriptionHash` field.

On its own side, `WALLET` must do the same thing before hashing the metadata and checking its hashed value against the `descriptionHash` field of the invoice received from `SERVICE`.

If `WALLET` sends more `payerid` fields than requested by `SERVICE`, `SERVICE` should still append everything as received.

`WALLET` must not send expected `SERVICE` to append to metadata if `SERVICE` hadn't included the `payerIDs` record in the first response, as that would mean `SERVICE` doesn't understand LUD-18 at all.

### Pseudocode example for calculating `descriptionHash` with `payerids`

```
originalServiceMetadata = '[["text/plain", "description"], ["image/png;base64", "AAA=="]]'
urlEncodedPayerIds = '%5B%7B%22tag%22%3A%22name%22%2C%22value%22%3A%22bob%22%7D%2C%7B%22tag%22%3A%22auth%22%2C%22value%22%3A%2202c9323d02fc164f89c8f688dbfba8aad69a96fa8f6253ba8cce2c6f1546073fa3%22%2C%22sig%22%3A%222afd21794e2a801d0d516584ceebe1a24ed8991dd5ec708259aeaee5c0d2d1437542b689ee5d39e619a01a257142d49c18a4af3088c46ce87e2d941a1bcc7210%22%7D%2C%7B%22tag%22%3A%22identifier%22%2C%22value%22%3A%22bob%40bob.com%22%7D%2C%7B%22tag%22%3A%22pubkey%22%2C%22value%22%3A%2203ee58475055820fbfa52e356a8920f62f8316129c39369dbdde3e5d0198a9e315%22%7D%5D'
payerIds = urldecode(urlEncodedPayerIds)
descriptionHash = sha256(utf8(metadata + payerids))
```
