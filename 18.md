LUD-18: Payer identity in `payRequest` protocol.
================================================

`author: akumaigorodski` `author: hampus_s` `author: fiatjaf`

---

The idea here is that the payer can identify itself when paying. The scope varies from free-form names (or [LUD-16](16.md) internet identifiers) useful for loose identification in comments or similar things, to cryptographic keys for proof of payment, to authentication keys for future login into a `SERVICE`'s website after a payment and other use cases.

Aside from that, the payer ids are also committed to the invoice by means of the `descriptionHash` property, which ensures strong cryptographic guarantees for proof of payment.

## 1. `payerIDs` record

If `SERVICE` wants to get one or more types of payer identities from `WALLET` then it must alter its JSON response to the first callback to include a `payerIDs` field, as follows:

```diff
 {
   callback: String,
   maxSendable: MilliSatoshi,
   minSendable: MilliSatoshi,
   metadata: String,
+  payerIDs: {
+    "name": { "mandatory": Boolean },
+    "pubkey": { "mandatory": Boolean },
+    "identifier": { "mandatory": Boolean },
+    "email": { "mandatory": Boolean },
+    "auth": {
+       "mandatory": Boolean,
+       "k1": String // hex encoded 32 bytes of challenge
+    ],
+    ...other fields may be negotiated
+  },
   tag: "payRequest",
 }
```

## 2. Specifying payer identity before sending a payment

In response to seeing a `payerIDs` record in initial response from `SERVICE`, `WALLET` attaches a `payerid` query parameter to LNURL-PAY callback with value set to a JSON object:

```diff
- <callback><?|&>amount=<milliSatoshi>
+ <callback><?|&>amount=<milliSatoshi>&payerid=<urlencode({json object})>
```

The JSON object MUST have the following format:

```
{
  "name": <free form string>,
  "pubkey": hex(<randomly generated secp256k1 pubkey>),
  "auth": {
    "key": hex(<linkingKey>),
    "sig": hex(sign(utf8ToBytes(<k1>), <linkingPrivKey>)) // following LUD-04
  },
  "email": <email address>,
  "identifier": <internet identifier>,
  ...other fields may be included if supported by wallet and requested by service
}
```

Each key in this JSON object should correspond to a requested payerid from the `payerIDs` record received from `SERVICE`.

`WALLET` CAN send any of the payer id kinds if they are listed in the `payerIDs` record. But if any is marked as `"mandatory": true` `WALLET` must send it if it can, otherwise do not proceed with the payment flow.

`WALLET` SHOULD NOT send payer identity types omitted in `payerIDs` record, none at all if record is not present.

## 3. Committing payer to the invoice

If `SERVICE` requests (section 1) and `WALLET` sends a `payerid` record in the callback (section 2), the payer IDs must be committed to the metadata before the invoice is created.

`SERVICE` MUST append it to the metadata as it was received (after url-decoding), as in the following example:

```diff
 [["text/plain", "description"], ["image/png;base64", "AAA=="]]
+[["text/plain", "description"], ["image/png;base64", "AAA=="]]{<identity records>}
```

After doing that, `SERVICE` can proceed to hash the metadata and include that hash in the generated BOLT11 invoice as the `descriptionHash` field.

On its own side, `WALLET` must do the same thing before hashing the metadata and checking its hashed value against the `descriptionHash` field of the invoice received from `SERVICE`.

If `WALLET` sends more `payerid` fields than requested by `SERVICE`, `SERVICE` should still append everything as received.

`WALLET` must not expect `SERVICE` to append the identity records to the metadata if `SERVICE` hadn't included the `payerIDs` record in the first response, as that would mean `SERVICE` doesn't understand LUD-18 at all.

### Pseudocode example for calculating `descriptionHash` with `payerids`

```
originalServiceMetadata = '[["text/plain", "description"], ["image/png;base64", "AAA=="]]'
urlEncodedPayerIds = '%7B%22name%22%3A%22bob%22%2C%22auth%22%3A%7B%22key%22%3A%2202c9323d02fc164f89c8f688dbfba8aad69a96fa8f6253ba8cce2c6f1546073fa3%22%2C%22sig%22%3A%222afd21794e2a801d0d516584ceebe1a24ed8991dd5ec708259aeaee5c0d2d1437542b689ee5d39e619a01a257142d49c18a4af3088c46ce87e2d941a1bcc7210%22%7D%2C%22identifier%22%3A%22bob%40bob.com%22%2C%22pubkey%22%3A%2203ee58475055820fbfa52e356a8920f62f8316129c39369dbdde3e5d0198a9e315%22%7D'
payerIds = urldecode(urlEncodedPayerIds)
descriptionToBeHashed = metadata + payerids
descriptionToBeHashed == '[["text/plain", "description"], ["image/png;base64", "AAA=="]]{"name":"bob","auth":{"key":"02c9323d02fc164f89c8f688dbfba8aad69a96fa8f6253ba8cce2c6f1546073fa3","sig":"2afd21794e2a801d0d516584ceebe1a24ed8991dd5ec708259aeaee5c0d2d1437542b689ee5d39e619a01a257142d49c18a4af3088c46ce87e2d941a1bcc7210"},"identifier":"bob@bob.com","pubkey":"03ee58475055820fbfa52e356a8920f62f8316129c39369dbdde3e5d0198a9e315"}'
descriptionHash = sha256(utf8(descriptionToBeHashed))
```
